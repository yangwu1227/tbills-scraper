[{"name": "app.py", "content": "from pathlib import Path\nfrom typing import List, Union\n\nimport plotly.graph_objects as go\nimport polars as pl\nfrom plot_utils import plot_spreads_heatmap, plot_yield_curve_spline\nfrom shiny import reactive, render\nfrom shiny.express import render, ui\nfrom shinywidgets import render_plotly\n\n# ---------------------------- MathJax setup (v3) ---------------------------- #\n\n# Load MathJax v3 and configure $...$ / $$...$$\nMATHJAX_CONFIG = \"\"\"\nwindow.MathJax = {\n  tex: { \n    inlineMath: [['$', '$'], ['\\\\\\\\(', '\\\\\\\\)']],\n    displayMath: [['$$', '$$'], ['\\\\\\\\[', '\\\\\\\\]']],\n    processEscapes: true,\n    processEnvironments: true\n  },\n  options: { \n    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],\n    ignoreHtmlClass: 'tex2jax_ignore',\n    processHtmlClass: 'tex2jax_process'\n  },\n  startup: {\n    ready: () => {\n      MathJax.startup.defaultReady();\n      // Custom initialization if needed\n    }\n  }\n};\n\"\"\"\n\n# Re-typeset function for dynamic content\nMATHJAX_RETYPESET = \"\"\"\nif (window.MathJax && window.MathJax.typesetPromise) {\n  window.MathJax.typesetPromise()\n    .then(() => console.log('MathJax typeset complete'))\n    .catch((err) => console.error('MathJax typeset error:', err));\n}\n\"\"\"\n\nui.head_content(\n    ui.tags.script(MATHJAX_CONFIG),\n    ui.tags.script(src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js\"),\n)\n\n# --------------------------- Reactive data source --------------------------- #\n\n\n@reactive.calc\ndef daily_yields() -> pl.DataFrame:\n    return pl.read_csv(Path(__file__).parent / \"data\" / \"daily_yields.csv\")\n\n\n@reactive.calc\ndef break_even_yields() -> pl.DataFrame:\n    return pl.read_csv(Path(__file__).parent / \"data\" / \"break_even_yields.csv\")\n\n\n# ---------------------------- Layout: Multi-page ---------------------------- #\n\nwith ui.navset_bar(id=\"pages\", title=\"Daily Treasury Bill Yields\"):\n    # -------------------------- Page 1: Curve & Spreads ------------------------- #\n\n    with ui.nav_panel(\"Curve & Spreads\"):\n        # Two cards side by side\n        with ui.layout_columns(fill=True, fillable=True):\n            with ui.card(full_screen=True):\n                ui.card_header(\"Yield Curve (Cubic Spline)\")\n\n                @render_plotly\n                def yield_curve() -> go.Figure:\n                    data: pl.DataFrame = daily_yields()\n                    fig: go.Figure = plot_yield_curve_spline(\n                        maturities=data[\"maturity\"].to_numpy(),\n                        yields=data[\"yield_pct\"].to_numpy(),\n                        title=None,\n                        subtitle=None,\n                        n_points=1000,\n                        marker_size=5,\n                        line_width=2,\n                        show_legend=False,\n                        y_buffer=0.05,\n                        y_tick_interval=0.1,\n                    )\n                    return fig\n\n                ui.markdown(\n                    \"\"\"\n                    - Upward slope \u2192 signals growth expectations, risk premium for time (steep slope = strong shift in expectations/risk premium)  \n                    - Downward (inverted) slope \u2192 signals lower future rates, recession risk  \n                    - Flat curve \u2192 short- and long-term yields similar, uncertainty  \n                    \"\"\"\n                )\n\n            with ui.card(full_screen=True):\n                ui.card_header(\n                    \"Yield Spread (Spread = Shorter % \u2212 Longer % Reported in Percentage Points)\"\n                )\n\n                @render_plotly\n                def yield_spread() -> go.Figure:\n                    data: pl.DataFrame = daily_yields()\n                    fig: go.Figure = plot_spreads_heatmap(\n                        maturities=data[\"maturity\"].to_numpy(),\n                        yields=data[\"yield_pct\"].to_numpy(),\n                        title=None,\n                        subtitle=None,\n                        colorscale=\"RdBu\",\n                        marker_size=40,\n                        text_size=12,\n                        show_values=True,\n                    )\n                    return fig\n\n    # ----------------- Page 2: Break-Even Implied Forward Yields ---------------- #\n\n    with ui.nav_panel(\"Break-Even Implied Forward Yields\"):\n        with ui.layout_columns(fill=True, fillable=True):\n            # Break-even implied forward yield\n            with ui.card(full_screen=False):\n                ui.card_header(\"Break-Even Implied Forward Yield (365-day Horizon)\")\n\n                @render.data_frame\n                def break_even_table() -> render.DataTable:\n                    data: pl.DataFrame = break_even_yields()\n                    return render.DataTable(\n                        data=data,\n                        width=\"100%\",\n                        height=\"300px\",\n                        editable=True,\n                    )\n\n        # Interpretation\n        with ui.layout_columns(fill=True, fillable=True):\n            with ui.card(full_screen=True):\n                ui.card_header(\"Interpretation & Decision Rule\")\n\n                @render.ui\n                def interpretation() -> List[Union[ui.HTML, ui.Tag]]:\n                    content = r\"\"\"\n                    **What it is.** For any pair *(shorter weeks \u2192 longer weeks)*, the break-even implied forward yield, $y_{\\mathrm{be}}$, is the **constant annualized yield** that,\n                    if we earn it on every short-bill roll (including the final stub), makes our **gross return factor** (wealth multiple) over the horizon **exactly equal** to buying\n                    the longer bill and compounding it to the same horizon.\n\n                    - A **stub** is the final partial period of a short-bill investment that does not complete a full roll.\n                    - The [coupon-equivalent yield](https://www.investopedia.com/terms/c/couponequivalentrate.asp) (**CEY**) is each bill's yield based on the purchase price, discount,\n                      and a 365-366 day count convention.\n\n                    Formally, with day-count base $dc=365$ and horizon $H=365$ days:\n\n                    - Short tenor: maturity $m_s$ days; full rolls $k_s=\\left\\lfloor \\tfrac{H}{m_s}\\right\\rfloor$; stub $r_s=H-k_s\\,m_s$\n                    - Long tenor: maturity $m_l$ days; observed coupon-equivalent yield $y_l$; full rolls $k_l=\\left\\lfloor \\tfrac{H}{m_l}\\right\\rfloor$; stub $r_l=H-k_l\\,m_l$\n\n                    The break-even identity used to solve for $y_{\\mathrm{be}}$ is\n\n                    $$\n                    \\bigl(1+y_{\\mathrm{be}}\\tfrac{m_s}{dc}\\bigr)^{k_s}\n                    \\bigl(1+y_{\\mathrm{be}}\\tfrac{r_s}{dc}\\bigr)\n                    \\;=\\;\n                    \\bigl(1+y_l\\tfrac{m_l}{dc}\\bigr)^{k_l}\n                    \\bigl(1+y_l\\tfrac{r_l}{dc}\\bigr)\n                    $$\n\n                    **How one number covers many rolls.** Even though we may roll the short bill several times, **one** threshold $y_{\\mathrm{be}}$ is sufficient: rolling **wins** **if and only if** the **geometric mean** of our realized per-period short-bill returns (each full roll and the stub) **exceeds** the return implied by $y_{\\mathrm{be}}$. If it is **below**, rolling the longer bill **wins**.\n\n                    - **$y_{\\mathrm{be}}$ is a per-reinvestment hurdle.** At each roll date, if the then-current short-bill CEY is above $y_{\\mathrm{be}}$, we stay ahead; if it is below, we fall behind.  \n                    - **Today\u2019s cushion.** $\\Delta = (\\text{today\u2019s short CEY}) - y_{\\mathrm{be}}$ is how much the short rate could fall, *on average across rolls*, before rolling no longer beats the longer bill.\n\n                    **Actionable decision rule**\n\n                    1. Fix our horizon at $H=365$ days. Choose a pair *(shorter \u2192 longer)* from the table.  \n                    2. Read off $y_{\\mathrm{be}}$ for that pair. This is our **constant hurdle** for every future roll of the short bill (under the stated horizon and long-leg choice).  \n                    3. **Expectation-based decision rule (ex-ante):**\n\n                        - If we **expect** the short-bill CEY to **average at least $y_{\\mathrm{be}}$** over the coming year (in geometric-mean terms across all rolls and the stub), we **roll the shorter tenor**.  \n                        - If we **expect** the short-bill CEY to **average below $y_{\\mathrm{be}}$**, we **buy the longer tenor** now.\n\n                    4. **At each roll date (dynamic policy):** We recompute with current rates and the remaining horizon, then act:\n\n                        - If the then-current short CEY $\\ge y_{\\mathrm{be}}$ (recomputed), we **keep rolling**.  \n                        - If it is $< y_{\\mathrm{be}}$, we **switch** into the longer tenor.\n\n                    **Examples (from the table)**\n\n                    - $4 \\rightarrow 26$ weeks: $y_{\\mathrm{be}}\\approx 4.016\\%$. If we believe 4-week CEYs will, on average over our rolls, be $\\ge 4.016\\%$, rolling 4-week should beat buying the 26-week today. If we expect them to average $< 4.016\\%$, we buy the 26-week.  \n                    - $4 \\rightarrow 52$ weeks: $y_{\\mathrm{be}}\\approx 3.822\\%$. If we expect the 4-week CEY to average $\\ge 3.822\\%$ over the year, rolling 4-week should beat buying the 52-week; otherwise, we lock the 52-week.\n\n                    **What this does and does not assume**\n\n                    - We use **coupon-equivalent yield (CEY)** on a $dc=365$ basis and an **integer-roll + self-consistent stub** convention (the leftover days are invested at the same rate we are solving for).  \n                    - We **ignore** taxes, transaction costs, bid-ask, settlement timing, and minimums. Since tax treatment is identical for both legs, the break-even rule is unchanged; when comparing TBills to other investments, we should compare **after-tax** yields.  \n                    - **Not a forecast.** $y_{\\mathrm{be}}$ is a threshold we compare our expectations to; realized results depend on the **path** of short rates at each roll.  \n                    - The computed $y_{\\mathrm{be}}$ is specific to the chosen pair $(m_s \\rightarrow m_l)$, today\u2019s $y_l$, and the horizon $H$. If any of these change (e.g., when we recompute on a later date), the threshold will generally change as well.\n\n                    **Usage**\n\n                    Use $y_{\\mathrm{be}}$ as a single, stable hurdle to drive the choice:\n\n                    - **Expect $\\ge y_{\\mathrm{be}}$** $\\Rightarrow$ **roll the shorter tenor**.  \n                    - **Expect $< y_{\\mathrm{be}}$** $\\Rightarrow$ **buy the longer tenor now**.  \n\n                    We monitor this at each roll; this dashboard will recompute $y_{\\mathrm{be}}$ with new rates.\n                    \"\"\"\n                    return [\n                        ui.markdown(content),\n                        ui.tags.script(MATHJAX_RETYPESET),\n                    ]\n", "type": "text"}, {"name": "__init__.py", "content": "", "type": "text"}, {"name": "plot_utils.py", "content": "from typing import List, Optional, Tuple\n\nimport numpy as np\nimport numpy.typing as npt\nimport plotly.graph_objects as go\nimport polars as pl\nfrom scipy.interpolate import CubicSpline\n\n\ndef plot_yield_curve_spline(\n    maturities: npt.NDArray[np.float64],\n    yields: npt.NDArray[np.float64],\n    title: Optional[str] = None,\n    subtitle: Optional[str] = None,\n    n_points: int = 1000,\n    marker_size: int = 8,\n    line_width: int = 2,\n    show_legend: bool = True,\n    y_buffer: float = 0.1,\n    y_tick_interval: float = 0.1,\n) -> go.Figure:\n    \"\"\"\n    Build an interactive yield curve chart with cubic spline interpolation.\n\n    Parameters\n    ----------\n    maturities : npt.NDArray[np.float64]\n        Array of maturity values (in weeks).\n    yields : npt.NDArray[np.float64]\n        Array of yield values in percentages (not decimal).\n    title : Optional[str]\n        Main figure title.\n    subtitle : Optional[str]\n        Subtitle shown under the main title.\n    n_points : int\n        Number of interpolation points for the spline curve, defaults to 1000.\n    marker_size : int\n        Size of the markers for raw data points, defaults to 8.\n    line_width : int\n        Line width for the spline fit, defaults to 2.\n    show_legend : bool\n        Whether to show the legend, defaults to True.\n    y_buffer : float\n        Extra buffer above and below the y-axis limits (in percentage points).\n    y_tick_interval : float\n        Spacing between y-axis ticks (in percentage points).\n\n    Returns\n    -------\n    fig : plotly.graph_objects.Figure\n        Plotly figure.\n    \"\"\"\n    rates: npt.NDArray[np.float64] = yields / 100.0\n    # Fit cubic spline\n    spline: CubicSpline = CubicSpline(maturities, rates)\n    xs: npt.NDArray[np.float64] = np.linspace(\n        float(maturities.min()), float(maturities.max()), n_points\n    )\n    ys: npt.NDArray[np.float64] = spline(xs)\n\n    # Compute y-axis range with buffer\n    min_y: float = min((rates.min() * 100), (ys.min() * 100)) - y_buffer\n    max_y: float = max((rates.max() * 100), (ys.max() * 100)) + y_buffer\n\n    # Round to nearest tick interval\n    min_y = np.floor(min_y / y_tick_interval) * y_tick_interval\n    max_y = np.ceil(max_y / y_tick_interval) * y_tick_interval\n\n    fig: go.Figure = go.Figure()\n    fig.add_trace(\n        go.Scatter(\n            x=maturities,\n            y=rates * 100,\n            mode=\"markers\",\n            name=\"Yield\",\n            marker=dict(\n                size=marker_size, color=\"red\", line=dict(width=1, color=\"black\")\n            ),\n            showlegend=show_legend,\n        )\n    )\n\n    fig.add_trace(\n        go.Scatter(\n            x=xs,\n            y=ys * 100,\n            mode=\"lines\",\n            name=\"Spline Fit\",\n            line=dict(width=line_width, color=\"red\"),\n            showlegend=show_legend,\n        )\n    )\n\n    if title is not None:\n        subtitle_html: str = f\"<br><sup>{subtitle}</sup>\" if subtitle else \"\"\n        fig.update_layout(title=f\"{title}{subtitle_html}\")\n\n    fig.update_layout(\n        xaxis_title=\"Maturity (weeks)\",\n        yaxis=dict(\n            title=\"Coupon Equivalent (%)\",\n            range=[min_y, max_y],\n            dtick=y_tick_interval,\n        ),\n        template=\"plotly_white\",\n        margin=dict(l=70, r=20, t=80, b=60),\n    )\n\n    return fig\n\n\ndef plot_spreads_heatmap(\n    maturities: npt.NDArray[np.float64],\n    yields: npt.NDArray[np.float64],\n    title: Optional[str] = None,\n    subtitle: Optional[str] = None,\n    colorscale: str = \"RdBu\",\n    marker_size: int = 30,\n    text_size: int = 8,\n    show_values: bool = True,\n) -> go.Figure:\n    \"\"\"\n    Build an interactive triangular 'heatmap' (scatter) of yield spreads. Spread\n    convention: Shorter minus Longer (in percentage points).\n\n    Parameters\n    ----------\n    maturities : npt.NDArray[np.float64]\n        Array of maturity values (in weeks).\n    yields : npt.NDArray[np.float64]\n        Array of yield values in percentages.\n    title : Optional[str]\n        Main figure title.\n    subtitle : Optional[str]\n        Subtitle shown under the main title describing the spread formula.\n    colorscale : str\n        Any Plotly colorscale, defaults to `RdBu`.\n    marker_size : int\n        Circle marker size.\n    text_size : int\n        Text annotation size.\n    show_values : bool\n        If True, annotate each circle with its spread value.\n\n    Returns\n    -------\n    fig : plotly.graph_objects.Figure\n        Plotly figure.\n    \"\"\"\n    labels: List[str] = [\n        f\"{int(mat)}w\" if float(mat).is_integer() else f\"{mat}w\" for mat in maturities\n    ]\n\n    # Upper-triangle indices (short < long)\n    coords: List[Tuple[int, int]] = [\n        (i, j) for i in range(len(maturities)) for j in range(len(maturities)) if i < j\n    ]\n    short_indices: npt.NDArray[np.int64] = np.array([i for i, j in coords])\n    long_indices: npt.NDArray[np.int64] = np.array([j for i, j in coords])\n\n    # Spread = shorter \u2212 longer (percentage points)\n    spreads: npt.NDArray[np.float64] = np.array(\n        [yields[i] - yields[j] for i, j in coords]\n    )\n\n    plot_data: pl.DataFrame = pl.DataFrame(\n        {\n            \"short_index\": short_indices,\n            \"long_index\": long_indices,\n            \"shorter_yield\": [yields[i] for i in short_indices],\n            \"longer_yield\": [yields[j] for j in long_indices],\n            \"spread\": spreads,\n        }\n    )\n\n    # Near the center (where RdBu is light), use black; otherwise white\n    # The \"light\" region heuristic: within 25% of the min/max range around the midpoint\n    vmin, vmax = spreads.min(), spreads.max()\n    vmid: np.floating = (vmin + vmax) / 2.0\n    band: np.floating = 0.25 * (vmax - vmin)\n    is_light: npt.NDArray[np.bool_] = (\n        plot_data[\"spread\"]\n        .is_between(float(vmid - band), float(vmid + band))\n        .to_numpy()\n    )\n    text_colors: npt.NDArray[np.str_] = np.where(is_light, \"black\", \"white\")\n\n    mask_white: npt.NDArray[np.bool_] = text_colors == \"white\"\n    mask_black: npt.NDArray[np.bool_] = text_colors == \"black\"\n\n    def make_trace(\n        mask: npt.NDArray[np.bool_], textcolor: str, show_colorbar: bool = False\n    ) -> go.Scatter:\n        subset: pl.DataFrame = plot_data.filter(mask)\n        return go.Scatter(\n            x=subset[\"long_index\"],\n            y=subset[\"short_index\"],\n            mode=\"markers+text\" if show_values else \"markers\",\n            text=[f\"{v:.2f}\" for v in subset[\"spread\"]] if show_values else None,\n            textposition=\"middle center\",\n            textfont=dict(color=textcolor, size=text_size),\n            marker=dict(\n                size=marker_size,\n                color=subset[\"spread\"],\n                colorscale=colorscale,\n                cmin=vmin,\n                cmax=vmax,\n                reversescale=True,\n                line=dict(color=\"black\", width=1),\n                colorbar=dict(title=f\"% Points\") if show_colorbar else None,\n                showscale=show_colorbar,\n            ),\n            hovertemplate=(\n                \"Shorter: %{customdata[0]:.2f} %<br>\"\n                \"Longer: %{customdata[1]:.2f} %<extra></extra>\"\n            ),\n            customdata=np.stack(\n                [subset[\"shorter_yield\"], subset[\"longer_yield\"], subset[\"spread\"]],\n                axis=-1,\n            ),\n            showlegend=False,\n        )\n\n    trace_white = make_trace(mask_white, \"white\", show_colorbar=False)\n    trace_black = make_trace(mask_black, \"black\", show_colorbar=True)\n\n    fig = go.Figure(data=[trace_white, trace_black])\n\n    if title is not None:\n        subtitle_html: str = f\"<br><sup>{subtitle}</sup>\" if subtitle else \"\"\n        fig.update_layout(title=f\"{title}{subtitle_html}\")\n\n    fig.update_layout(\n        xaxis=dict(\n            title=\"Longer Maturity (weeks)\",\n            tickmode=\"array\",\n            tickvals=list(range(len(labels))),\n            ticktext=labels,\n        ),\n        yaxis=dict(\n            title=\"Shorter Maturity (weeks)\",\n            tickmode=\"array\",\n            tickvals=list(range(len(labels))),\n            ticktext=labels,\n            autorange=\"reversed\",\n        ),\n        plot_bgcolor=\"white\",\n        margin=dict(l=70, r=20, t=80, b=60),\n    )\n\n    return fig\n", "type": "text"}, {"name": "data/break_even_yields.csv", "content": "Shorter Maturity (weeks),Shorter CEY (%),Longer Maturity (weeks),Longer CEY (%),Break-Even Implied Forward Yield (%)\n4,4.31,6,4.29,4.2867\n4,4.31,8,4.28,4.2735\n6,4.29,8,4.28,4.2768\n4,4.31,13,4.2,4.1849\n6,4.29,13,4.2,4.188\n8,4.28,13,4.2,4.1911\n4,4.31,17,4.16,4.1392\n6,4.29,17,4.16,4.1422\n8,4.28,17,4.16,4.1452\n13,4.2,17,4.16,4.1539\n4,4.31,26,4.02,3.9864\n6,4.29,26,4.02,3.9893\n8,4.28,26,4.02,3.9921\n13,4.2,26,4.02,4.0001\n17,4.16,26,4.02,4.0058\n4,4.31,52,3.86,3.7933\n6,4.29,52,3.86,3.7958\n8,4.28,52,3.86,3.7984\n13,4.2,52,3.86,3.8056\n17,4.16,52,3.86,3.8108\n26,4.02,52,3.86,3.8237\n", "type": "text"}, {"name": "data/daily_yields.csv", "content": "maturity,yield_pct\n4,4.31\n6,4.29\n8,4.28\n13,4.2\n17,4.16\n26,4.02\n52,3.86\n", "type": "text"}]